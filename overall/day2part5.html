<html>
  <head>
    <title>Web front-end html5 acceleration course (day 2)</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link type="text/css" rel="stylesheet" href="styles/style.css">
		<link type="text/css" rel="stylesheet" href="vendor/syntaxhighlighter/shCore.css"></link>
		<link type="text/css" rel="stylesheet" href="vendor/syntaxhighlighter/shThemeDefault.css"></link>
		<script type="text/javascript" src="vendor/syntaxhighlighter/shCore.js"></script>
		<script type="text/javascript" src="vendor/syntaxhighlighter/shBrushJScript.js"></script>
		<script type="text/javascript" src="vendor/syntaxhighlighter/shBrushXML.js"></script>
		<script type="text/javascript">
		    SyntaxHighlighter.all();
		</script>
		
	</head>
  <body>
		<p>
			<a href="day0part0.html">Before start</a>
			<a href="day1part0.html">Start day 1</a>
			<a href="day1part1.html">[1.1]</a>
			<a href="day1part2.html">[1.2]</a>
			<a href="day1part3.html">[1.3]</a>
			<a href="day1part4.html">[1.4]</a>
			<a href="day1part5.html">[1.5]</a>
			<a href="day2part0.html">Start day 2</a>
			<a href="day2part1.html">[2.1]</a>
			<a href="day2part2.html">[2.2]</a>
			<a href="day2part3.html">[2.3]</a>
			<a href="day2part4.html">[2.4]</a>
			<a href="day2part5.html">[2.5]</a>
			<a href="day2part6.html">[2.6]</a><a href="day2part7.html">[2.7]</a><a href="day3part0.html">Start day 3</a><a href="day3part1.html">[3.1]</a><a href="day3part2.html">[3.2]</a><a href="day3part3.html">[3.3]</a><a href="day3part4.html">[3.4]</a><a href="day3part5.html">[3.5]</a><a href="day3part6.html">[3.6]</a>
		</p>
		<h2>Communication between client and server, new kids (day 2, part 5)</h2>

		<h3>Application caching</h3>
		On of the differences compared to previous client server application architectures is that in the client server model the client program contained the business logic / the application program. This client program was often installed on the client. In the web model applications the program are served from the server and we cannot be sure that it will be cached by setting cache attributes in the way with did before. Even in the case of more client logic the logic is served from server on request. This has the following disadvantages: you need a connection to start your application. Application cache manifest caching is an attempt to solve this problem. Two warning needs to be made: 
		<ol>
			<li>as always is working with cache more complex and special attention is needed in relation to versioning of your cached information</li>
			<li>this technics works but has some subtile drawbacks you need to be aware of before using it in production. A more comprehensive solution is currently in it's early drafts: service workers.</li>
		</ol>
		<p>
An cache manifest file is a plain text file. In the file the folowing should and or can be described:
	</p>
		<pre class="brush: javascript;">
			CACHE MANIFEST
			CACHE
				/tobecachedfile.html 
			NETWORK
				/nevertobecachefiles.html
			FALLBACK
				/ifONLINEtakethisfile.html /ifNOTonlinetakethisfile.html
		</pre>
	<div class='excercise'>
		<br/>
		<b>Excercises:</b><br />
		<ol>
			<li>Test the <a href="day2part5/cachemanifest">day2part5/cachemanifest</a> example, by running the server and see the behaviour of calling the webpage after you shutdown the server. Check your console and network behaviour in your favourite browser</li>
			<li>Adjust the example to make you of the FALLBACK option (for example for the manifest hope picture)</li>
		</ol>
		<br />
	</div>
	
	
	TODO Remco start vanaf testroom/vospresentatie/requirebackbone http://localhost:8080/
		<h3>Websockets</h3>
		<p>
		This is one of the game changing new apis being part of the HTML5 stack. It is new interaction pattern. Currently most web pages including the ones working with ajax work on a request/ response interaction pattern. The client ask for url and the server sends the request information (content of the url) as response. Websockets are standardized socket connection. This are full duplex connection which mean that both: the client and the server can take initiative to send information. In this model the server can send information directly to the browser who need or can use the information. There are a number of (dis-)advantages of websockets.
		</p>
		<a href="http://www.apress.com/9781430247401">
		<img align="right" src="images/defguidehtml5websocket.png"> 
		</a>
		<p>
			Disadvantages:
		</p>
		<ol>
			<li>It is a new communication pattern. New standards, convention and best-practices still need to be sorted out.</li>
			<li>The secure version need to be used, because otherwise the changes are big that firwall routers etc</li>
			<li>The session need to be maintained (ping like), and reconnection must be done automatically after disconnection</li>
			<li>The connection is session based. Therefore needs session based staefull information on server side. Needs efficient handling of this session support which need special attention for site with a high number of users</li>
			<li>Not supported for relatively old browser</li>
		</ol>
		<p>
			Advantages:
		</p>
		<ol>
			<li>Pushing information from server to clients is possible</li>
			<li>Extremly small overhaed protocol, meaning far less bandwith needs</li>
			<li>Streaming information (both ways) is easy</li>
			<li>Works already in almost(!) every browser</li>
			<li>Monitoring client side can be done at totally different level: browser is actice instead of only user is active</li>
		</ol>
	<div class='excercise'>
		<br/>
		<b>Excercises:</b><br />
		<ol>
			<li>Walk through the <a href="http://socket.io/get-started/chat">http://socket.io/get-started/chat</a></li>
			<li>Discuss potentials of this technic/api</li>
		</ol>
		<br />
	</div>
		<h3>WebRTC</h3>
		<a href="http://shop.oreilly.com/product/0636920030911.do#">
		<img align="right" src="images/webrtcoreilly.gif"> 
		</a>
		<p>
		This is yet another game changing api/technic that is part of the HTML5 stack. WebRTC stands for Web Real-Time Communication. This protocol makes direct(!) communication between clients possible. You (apart from a very small initialization you do not need any central server. This is very different from all previously interaction patterns in which a browser is connect to a server. 
	</p>
	<div class='excercise'>
		<br/>
		<b>Excercises:</b><br />
		<ol>
			<li>Walk through the <a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">http://www.html5rocks.com/en/tutorials/webrtc/basics/</a></li>
			<li>Let's test <a href="day2part5/webrtc">day2part5/webrtc</a> with https://localhost:2029/.</li>
			<li>Discuss why it work / does not work.</li>
			<li>https://bitbucket.org/webrtc/codelab</li>
		</ol>
		<br />
	</div>
		<p>
			These API It is not yet supported as widespread as websockets, see also <a href="http://iswebrtcreadyyet.com/">http://iswebrtcreadyyet.com/</a>. But in IE it works with ChromeFrame. 
			The test is done with google A achilles of this protocol is the STUN server because it seems to be running under a predefined browser. In the web
		</p> 
		<p> <b>TODO</b> combining some of these tricks!! https://www.soundtrap.com/
		<p>
			Advantages of webRTC:
		</p> 
		<ol>
			<li>Video quality (far better then Flash)</li>
			<li>Low latency. Proofed by practice that communication between India and the Netherlands was very good</li>
			<li>Standard. Only native and propriatery solutions available between devices</li>
		</ol>
</body>

</html>

