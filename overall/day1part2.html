<html>
  <head>
    <title>Part Javascript testing of Web front-end html5 acceleration course</title>
		<link type="text/css" rel="stylesheet" href="styles/style.css">
		<link type="text/css" rel="stylesheet" href="vendor/syntaxhighlighter/shCore.css"></link>
		<link type="text/css" rel="stylesheet" href="vendor/syntaxhighlighter/shThemeDefault.css"></link>
		<script type="text/javascript" src="vendor/syntaxhighlighter/shCore.js"></script>
		<script type="text/javascript" src="vendor/syntaxhighlighter/shBrushJScript.js"></script>
		<script type="text/javascript">
		    SyntaxHighlighter.all();
		</script>
	</head>
  <body>
		<p>
			<a href="day0part0.html">Before start</a>
			<a href="day1part0.html">Start day 1</a>
			<a href="day1part1.html">[1.1]</a>
			<a href="day1part2.html">[1.2]</a>
			<a href="day1part3.html">[1.3]</a>
			<a href="day1part4.html">[1.4]</a>
			<a href="day1part5.html">[1.5]</a>
			<a href="day2part0.html">Start day 2</a>
			<a href="day2part1.html">[2.1]</a>
			<a href="day2part2.html">[2.2]</a>
			<a href="day2part3.html">[2.3]</a>
			<a href="day2part4.html">[2.4]</a>
			<a href="day2part5.html">[2.5]</a>
			<a href="day2part6.html">[2.6]</a>
		</p>
		<a href="http://shop.oreilly.com/product/0636920024699.do"><img src="images/TestableJavascript.jpg" align="right"> </a>
		<h2>Javascript testing (day 1, part 2)</h2>
		<h3>Why test javascript?</h3>
		Testing should be a crucial part of the development practice. Even more in javascript as in other languages. 
		A few reasons why this is even more important than it is several other languages/programming environments.
		
		<ul>
			<li>Javascript the bad parts (there are more then enough bad parts)</li>
			<li>Dynamic language (no static compile)</li>
			<li>Cross browser issues (javscript runs differently on different javascript engines/browsers)</li>
			<li>Although javascript started for very simple interactive elements on a webpage. It is becoming a language for full scale applications. This means complexity increases which cannot easily be controlled without tests.</li>
			<li>It is a must for maintainable and refactarable software under quality control</li>
		</ul>
			
		<h3>The first testing framework</h3>
		This is a first example of javascript testing library. It uses the yahoo testscript that is part of YUI3. 
		It is a unit test framework. 
		See <a href="https://github.com/yui/yui3/releases">https://github.com/yui/yui3/releases</a> for all more recent versions of this library. See <a href="http://yuilibrary.com/yui/docs/test/">http://yuilibrary.com/yui/docs/test/</a> for the documentation of this testing framework.
		<h3>How does TTD work?</h3>
		For the ones whe do not know where TDD stands for: <b>T</b>est <b>D</b>riven <b>D</b>evelepment. What is already in the name of 'Test driven' is that tests are the driving force. So let's start with our first javascript test (made with YUI3 library).
		<pre class="brush: javascript;">
		 	var testCase1 = new Y.Test.Case( {
				name: 'Sum Test', 
				testSumSimple: function () {
					Y.Assert.areSame(
						sum(2, 2), 
						4, 
						'2 + 2 does not equal 4?');
			}});
		</pre>
		<p>In a complete example we need some extra setup to make the results show up in a webpage. The complete example for this
				lesson is shown <a href="day1part2/example/testLogConsole.html">here</a>. The real test starts with Y.Assert which in this case wants to
				see that to parts are 				the same (sum(2,2) equals 4). As a wrapper of the things that are reported there is a
				Test.Case which is the level of reporting and more as one tests can be combined into one testcase.</p>
				
		<p>Without having the code implement this testcase should fail. That is the practice of TDD:</p>
			<ul>
				<li>write test</li>
				<li>fail test</li>
				<li>write code</li>
				<li>succeed test</li>
				<li><b>refactor</b>!</li>
			</ul>
		<p>The first two steps and last step are the most important steps in TDD. Do you understand why it is so important that a test first fails?</p>
		<p>Tests will be run in this page: <a href="testLogConsole.html">testLogConsole.html</a>
		The image beneath shows the failing test<img src='images/TestLogConsoleFail.png'></p>
		<p>Beneath is the very oversimplified version of a solution to make the test above succeed.
		<pre class="brush: javascript;">
			function sum(a, b) {
			        return a + b;
			}
		</pre>
		After re-running the test this test should pass. <img src='images/TestLogConsolePass.png'>

		In this very simple example the refactor step out of the cycle of write test, fail, write code, fail, succceed, improve/refactor. In total this example has the following files needed for the main setup. To make this work within a course setting there are some extra files includede for the style of code (by <a href="http://alexgorbatchev.com/SyntaxHighlighter">syntaxhighlighter</a>)
		
		<p>This first example consists of the following files:</p>
		<ul>
			<li><b>day1part2/example/app/sum.js:</b> The code that needs to be tested</li>
			<li><b>day1part2/example/tests/sumTests.js:</b> The tests</li>
			<li><b>day1part2/example/TestLogConsole.html:</b> An overview of the test and if they succeed or fail</li>
			<li><b>day1part2/example/vendor/yui-min.js:</b> The library used for this test </li>
			<li><b>day1part1.html:</b> This file</li>
		</ul>
		<p class='excercise'>
			<br/>
			<b>Excercises:</b>
			<br/><br/>
				<ul class='excercise'>
				<li>Write a few tests for a function that only sets the first letter of the input to upper case</li>
					<ul>
						<li>'test case 1' becomes 'Test case 1'</li>
						<li>'Test case 2' becomes 'Test case 1'</li>
						<li>'Test case 3' does not becomes 'Test case 3'</li>
						<li>' test case 4' becomes ' Test case 4'</li>
						<li>'.test case 5' becomes '.Test case 5'</li>
						<li>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test case 6' becomes 
								'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test case 6'</li>
						<li>4 returns 4</li>
						<li>true returns true</li>
						<li>'.@$%#&46' returns '.@$%#&46'</li>
						<li>more .....</li>
					</ul>
				<li>Write the code that succeeds in all above cases</li>
				<li>Refactor your code!</li>
			</ul>
		<a href="http://shop.oreilly.com/product/9780596802806.do"><img src="images/HighPerformanceJavascript.jpg" align="right"> </a>
		<h3>Time based tests</h3>
		There are more ways to test the performance of javascript functions. As was previously shown in the browser development tools there is a lot already provided in the current browser. An example of a solution that probably is easier to automate and more controllable on what is contributed by Zach Nicholas. More information, see <a href="http://developer.yahoo.com/yui/profiler/">http://developer.yahoo.com/yui/profiler/</a> or some examples in 
		in the book <a href="http://shop.oreilly.com/product/9780596802806.do">high performance javascript</a>.
		<pre class="brush: javascript;">
			var count = 10000, i, element;

			Y.Profiler.start('createElement');
			for (i = 0; i < count; i++) {
				element = document.createElement('div'); 
			}
			Y.Profiler.stop('createElement');
			alert('created ' + count + ' in ' + Y.Profiler.getAverage('createElement') + 'ms');
		</pre>

		<h3>User-interface based tests</h3>
		<p>
			For a lot of organisations this type of tests are difficult. It is closest to the outcome and can realy proof that the whole chain of making code work correctly. The single most used tools in this context was Selenium. See for example page 138 in the OReilly book: testable_javascript for more detail on how to use Selenium
		</p>
		<p>		
			The main disadvantages of running Selinum was that it needed browser instances and runs realy in the browser making it rather slow. But currently there seems to be new ways of running test headless due to a combination of the tools: phantom and casper.
		</p>
		<a href="http://phantomjs.org/"><img src="images/PhantomJS.png" align="right"> </a>
		
		
		<p>PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.</p>Next to webpage testing it can be used to do screen capture (see also the excercise). As even the screen format can be set. This can also be used to make an automated visual output of many different form factors to be able to do a quick visual check. 
		<div class='excercise'>
			<br/>
			<b>Excercises:</b>
			<br/><br/>
			Run from the commandline: <br/>
			$ npm phantom<br/>
			make similar code as beneath and run it from the commandline
		</div>
		<pre class="brush: javascript;">
var page = require('webpage').create();
page.open(	'http://tweakers.net/', function () {
    page.render('tweakers.png');
    phantom.exit();
});		
		</pre>
		</p>
		<a href="http://casperjs.org/"><img src="images/Casper.png" align="right"> </a>
		<p>Casper is ....todo
		And then nog casper see testable javsascript, zie page 166 of testable javacsript (todo aanpassen aan een bestande mini app die we direct in elkaar moeten zetten voor testdoeleinden)
		</p>

		<div class='excercise'>
			<br/>
			<b>Excercises:</b>
			<br/><br/>
			Run from the commandline: <br/>
			$ npm install -g casperjs<br/>
			make similar code as beneath and run it from the commandline<br/>
		</div>
		<pre class="brush: javascript;">
			 var casper = require('casper').create();
			    casper.start('http://search.yahoo.com/', function() {
			        this.fill('form#sf', { "p": 'JavaScript' }, false);
			        this.click('#yschbt');
			});
			    casper.then(function() {
			        this.test.assertExists('#resultCount', 'Got result count');
			});
			    casper.run(function() {
			       this.exit();
			});
		</pre>
		<a href="http://shop.oreilly.com/product/0636920028277.do"><img src="images/JavascriptTestingWithJasmine.jpg" align="right"> </a>
		
		<h3>Behaviour driven development</h3>
		<p>
			In the previous example we wrote tests. But these tests are meant to test of something is done accoording to the specs. Wouldn't it be nice if we could uses the specs instead of making extra tests. This has more advantages. Of course there is also some translation needed going from specs to tests. Another advantage is that it help getting specs more specific and concrete by adding examples, adhering to a proven format and implements that when a requirement cannot be tested we could hardly name it a spec. Another pro is that a lot of test/spec are readable by end users. Making these testspecs is a more solid way that the result was conform what was described during design and is continuously used while making the solution. 
			</p>
			<p>
		Beneath is the very trivial/ canonical example of hello world for jasmine. It does of course not show the potential but is helpfull in explaning the basis structure. The describe function describes the component are functional grouping of test (and hopefully aligned code). The "it" function describes the specification, in this trivials it is an action: "says hello". The expect function determines how we can prove ourselfs that the spec is fullfilled.
		<p>
		<pre class="brush: javascript;">
			describe("Hello world", function() {
				it("says hello", function() {
					expect(helloWorld()).toEqual("Hello world!");
				});
			});
		</pre>
		
		<div class='excercise'>
			<br/>
			<b>Excercises:</b>
			<br/><br/>
			Download the standalone runner from: <br/>
			<a href="https://github.com/pivotal/jasmine/blob/master/dist/jasmine-standalone-2.0.0.zip">
				https://github.com/pivotal/jasmine/blob/master/dist/jasmine-standalone-2.0.0.zip
			</a><br/>
			run the example and inspect how it works<br/>
			rewrite one of the previous tests into a spec<br/><br/>
		</div>
		
		
	</body>
</html>